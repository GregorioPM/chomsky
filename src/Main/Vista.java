/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package Main;

import java.awt.Font;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.swing.JOptionPane;
import javax.swing.SpringLayout;

/**
 *
 * @author GREGORIO
 */
public class Vista extends javax.swing.JFrame {

    /**
     * Creates new form Vista
     */
    
    Chomsky chomsky=new Chomsky();
    List<String> variablesNoTerminales=new ArrayList<>();
    List<String> variablesTerminales=new ArrayList<>();
    List<String> transcionesSigma= new ArrayList<>();
    Map<String,List<String>> transiciones=new HashMap<String,List<String>>();
    Map<String,List<String>> transicionesfinal=new HashMap<String,List<String>>();
    Map<String,String> variableTerminal=new HashMap<String,String>();
    List<String> borrarNoGeneradoras=new ArrayList<>();
    String varInicial="";
    String contenidoLista="";
    String contenidoListaInicial="";
    String[] cadenaSplit= new String[4];
    List<String> probando = new ArrayList<>();
    int contadorParaNoGeneradora=0;
    List<String> produccionesNuevas = new ArrayList<>();
    Map<String,List<String>> mapNuevosSimbolos= new HashMap<>();
    Map<String,List<String>> variablesFinales= new HashMap<>();
    boolean entro=false;
    int contadorNormalizaar=0;
    int contadorNormalizar2=0;
    boolean probarVt = false;
    boolean probarVnt= false;

     
     public static String subscript(int subIndice) {
         
         String str = String.valueOf(subIndice);
    
         String[] separado= str.split("");
         System.out.println(separado.length);
         String b="";
         for(String sub: separado){
             b=b+subindice(sub);
         }
         return b;
        
}
     //Para concatenar subIndice a la variable
     public static String subindice(String str){
     str = str.replaceAll("0", "₀");
        str = str.replaceAll("1", "₁");
        str = str.replaceAll("2", "₂");
        str = str.replaceAll("3", "₃");
        str = str.replaceAll("4", "₄");
        str = str.replaceAll("5", "₅");
        str = str.replaceAll("6", "₆");
        str = str.replaceAll("7", "₇");
        str = str.replaceAll("8", "₈");
        str = str.replaceAll("9", "₉");
        return str;
     }



    public Vista() {
        initComponents();
        this.setLocationRelativeTo(null);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        InputVariablesTerminales = new javax.swing.JTextField();
        jButton1 = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        TextVariablesTerminales = new javax.swing.JTextField();
        TextVariableInicial = new javax.swing.JTextField();
        jLabel4 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        TextSigma = new javax.swing.JTextArea();
        jButton3 = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        InputVariablesTerminales.setFont(new java.awt.Font("Monospaced", 0, 15)); // NOI18N
        InputVariablesTerminales.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                InputVariablesTerminalesActionPerformed(evt);
            }
        });

        jButton1.setFont(new java.awt.Font("Monospaced", 0, 14)); // NOI18N
        jButton1.setText("Convertir");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jLabel1.setFont(new java.awt.Font("Monospaced", 1, 24)); // NOI18N
        jLabel1.setText("Gramatica Chomsky");

        jLabel2.setFont(new java.awt.Font("Monospaced", 0, 15)); // NOI18N
        jLabel2.setText("Variables no Terminales");

        jLabel3.setFont(new java.awt.Font("Monospaced", 0, 15)); // NOI18N
        jLabel3.setText("Variables Terminales");

        TextVariablesTerminales.setFont(new java.awt.Font("Monospaced", 0, 15)); // NOI18N
        TextVariablesTerminales.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                TextVariablesTerminalesActionPerformed(evt);
            }
        });

        TextVariableInicial.setFont(new java.awt.Font("Monospaced", 0, 15)); // NOI18N
        TextVariableInicial.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                TextVariableInicialActionPerformed(evt);
            }
        });

        jLabel4.setFont(new java.awt.Font("Monospaced", 0, 15)); // NOI18N
        jLabel4.setText("Variable Inicial");

        jLabel5.setFont(new java.awt.Font("Monospaced", 0, 15)); // NOI18N
        jLabel5.setText("Sigma");

        TextSigma.setColumns(20);
        TextSigma.setFont(new java.awt.Font("Monospaced", 0, 15)); // NOI18N
        TextSigma.setRows(5);
        jScrollPane1.setViewportView(TextSigma);

        jButton3.setText("< Regresar");
        jButton3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton3ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(20, 20, 20)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(10, 10, 10)
                        .addComponent(jButton3)
                        .addGap(104, 104, 104)
                        .addComponent(jLabel1)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel4)
                            .addComponent(jLabel5)
                            .addComponent(jLabel3)
                            .addComponent(jLabel2))
                        .addGap(23, 23, 23)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 333, Short.MAX_VALUE)
                            .addComponent(TextVariableInicial)
                            .addComponent(TextVariablesTerminales)
                            .addComponent(InputVariablesTerminales))
                        .addGap(22, 22, 22))))
            .addGroup(layout.createSequentialGroup()
                .addGap(241, 241, 241)
                .addComponent(jButton1)
                .addGap(0, 0, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(6, 6, 6)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(jButton3))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(InputVariablesTerminales, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel2))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(TextVariablesTerminales, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel3))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(TextVariableInicial, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel4))
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(18, 18, 18)
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 231, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 38, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addContainerGap())
                    .addGroup(layout.createSequentialGroup()
                        .addGap(31, 31, 31)
                        .addComponent(jLabel5)
                        .addContainerGap(257, Short.MAX_VALUE))))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void InputVariablesTerminalesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_InputVariablesTerminalesActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_InputVariablesTerminalesActionPerformed

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        
        //Primero tomo todas las estructuras y las vacio por si se utiliza por segunda vez el normalizar
        transicionesfinal.keySet().removeIf(key-> !key.equals("GREGORIO"));
        contadorNormalizaar=0;
        borrarNoGeneradoras.removeAll(borrarNoGeneradoras);
        if(!borrarNoGeneradoras.isEmpty()){
        borrarNoGeneradoras.stream().forEach(ss->System.out.println("Imprime no generadora "+ ss));
        }
        transcionesSigma.removeAll(transcionesSigma);
        variablesTerminales.removeAll(variablesTerminales);
        variablesNoTerminales.removeAll(variablesNoTerminales);
        variablesFinales.clear();
        
        if(!variablesNoTerminales.isEmpty()){
            for(String b: variablesTerminales){
                transiciones.remove(b);
            }
        }
        
        
        chomsky.TextArea.setText("");
        chomsky.setVisible(false);
        
        //Aqui asigno a las estrucutura de datos las variables no terminales y terminales, sigma
        String varNoTer= InputVariablesTerminales.getText();
        variablesNoTerminales= new ArrayList<String>(Arrays.asList(varNoTer.split(",")));
        variablesNoTerminales.stream()
                            .forEach(vt -> {
                                            esString(vt.trim(),"La variable no terminal ");
                                            System.out.println("variable no terminal: " +vt);});
        String varTer= TextVariablesTerminales.getText();
        variablesTerminales= new ArrayList<String>(Arrays.asList(varTer.split(",")));
        variablesTerminales.add("ε");
        variablesTerminales.add("λ");
        variablesTerminales.stream()
                            .forEach(vt -> {
                                            noEsNumero(vt.trim(),"La variable terminal ");
                                            System.out.println("variable terminal: " + vt);});
        varInicial = TextVariableInicial.getText();
        boolean estaVarInicial = variablesNoTerminales.stream()
                                .anyMatch(vnt-> vnt.equals(varInicial));
        
        //Se valida que la variable inicial se enceuntre en las variablesnoTerminales
        if(estaVarInicial==false){
            JOptionPane.showMessageDialog(rootPane, "La variable inicial " +varInicial +" no se encuentra en las variables no terminales");
        }else{
        System.out.println(estaVarInicial);
        
        
        chomsky.setString(TextSigma.getText());
        
        transiciones=null;
        
        
        String a;
        
        
        //Se imprime en textarea sigma sus transiciones
        chomsky.TextArea.setText(" --> SIGMA SUS TRANSICIONES ...."  );
        
        //Se asigna al map las transiciones
        //Elimina produccion no generadoras de la transicion
        //Obtiene los key que todavia existen en el map y validan si tiene una variable inutil
        //Recibe como parametros los key del map , lo recorre y validad si es no alcanzable y se borra la transicion
        guardarTransiciones(TextSigma.getText());
        
        chomsky.TextArea.setText(chomsky.TextArea.getText() + "\n"+ "\n" +" --> SE ELIMINA PRODUCCIONES NULAS"+ "\n");
        //En este metodo detecta las nulas no recibe nada por en el mismo metodo obtiene los key del map y los recorre y validad
        detectarNulas();
        
        chomsky.TextArea.setText(chomsky.TextArea.getText() + " \n \n " + " --> REEMPLAZANDO UNITARIAS .... \n ");
        //En este metodo identifica las nulas de las trancisiones y las reemplaza
        identificarProduccionesUnitarias();
        chomsky.TextArea.setText(chomsky.TextArea.getText() + " \n \n " + "--> NORMALIZAR LA GRAMATICA A FNC \n");
        chomsky.TextArea.setText(chomsky.TextArea.getText() + "\n" +" Normalizando Variables Terminales");
        int ContadorVT=0;
        variablesTerminales.remove("ε");
        variablesTerminales.remove("λ");
        for(String vt: variablesTerminales){
            variableTerminal.put(vt, "T"+subscript(ContadorVT));
            chomsky.TextArea.setText(chomsky.TextArea.getText() + " \n " + vt + "→T"+subscript(ContadorVT));
            ContadorVT++;
        }
            System.out.println("Map Terminales:\n" + variableTerminal);
        normalizar();      
        if(!probarVnt && !probarVt){
            chomsky.setVisible(true);
        }
        
        
        }
        
        
        /*if(!validarString(InputVariablesTerminales.getText().trim())){
            JOptionPane.showMessageDialog(rootPane, "LOS DATOS NO SON VALIDOS");
        }*/
    }//GEN-LAST:event_jButton1ActionPerformed

    private void TextVariablesTerminalesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_TextVariablesTerminalesActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_TextVariablesTerminalesActionPerformed

    private void TextVariableInicialActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_TextVariableInicialActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_TextVariableInicialActionPerformed

    private void jButton3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton3ActionPerformed
        // TODO add your handling code here:
        Inicio inicio = new Inicio();
        inicio.setVisible(true);
        this.setVisible(false);
    }//GEN-LAST:event_jButton3ActionPerformed

    public void esString(String datos,String mensaje){
        if(!datos.matches("[a-zA-Z]")){
            JOptionPane.showMessageDialog(rootPane, mensaje + datos  + " no esta permitida");
            probarVnt = true;
        }
    }
    public void noEsNumero(String datos,String mensaje){
        if(!datos.matches("[0-9]") && !datos.matches("[λε]") && !datos.matches("[a-z]")){
            JOptionPane.showMessageDialog(rootPane, mensaje + datos  + " no esta permitido");
            probarVt=true;
        }
    }
    
    public void guardarTransiciones(String sigma){
        String[] obtenerTransiciones=sigma.split(",");
        String a=Arrays.toString(obtenerTransiciones);
        List<String> az=Arrays.stream(obtenerTransiciones)
                .map(t->t=t.trim())
                .collect(Collectors.toList());
       //az.stream().forEach(fs->System.out.println("Probando como ingresa"+fs));
       
       transiciones= az.stream()
               .map(tra-> tra.split("→"))
               .collect(Collectors.toMap(entry-> entry[0].trim(),entry-> convertirSigma(entry[1])));    
        System.out.println("La transcion del Map: \n" +transiciones);

        transcionesSigma=obtenerTransicionesSigma(transiciones);
        
        //Aca imprime en sigma
       //az.stream().forEach(x->chomsky.TextArea.setText(chomsky.TextArea.getText()+ "\n" + x ));
        List<String> TransicionesGeneranSigma=obtenerKeyMap(transiciones);
        List<String> imprimirOrdenSigma=ImprimirEnOrden(TransicionesGeneranSigma);
        imprimirMap(imprimirOrdenSigma);
        
        //transcionesSigma.stream().forEach(atr->System.out.println("Transiciones Sigma: "+atr));

        //asignar a generadoras las q no son
        transiciones.entrySet()
                .stream()
                .forEach(e-> generadores(e.getKey(),e.getValue()));
        
        
        //System.out.println("Index de " + borrarNoGeneradoras.indexOf("SS"));
        contadorParaNoGeneradora= 0;
        borrarNoGeneradoras.stream()
                .forEach(bTran-> {
                    System.out.println(bTran);
                    System.out.println(varInicial);
                    if(!bTran.equals(varInicial)){
                        System.out.println("Probando q llega en no generadoras: "+ bTran);
                        if(esRecursiva(bTran)){
                            contadorParaNoGeneradora++;
                          if(contadorParaNoGeneradora==1){
                              chomsky.TextArea.setText(chomsky.TextArea.getText() +"\n" + "\n"  +" --> ELIMINANDO NO GENERADORAS" +"\n");
                          }
                          
                          chomsky.TextArea.setText(chomsky.TextArea.getText()+ "\n"+" La transicion " +  bTran +" no es generadora");
                          
                            //System.out.println("Eliminar despues de validar recursivida: " +bTran);
                          transiciones.remove(bTran);
                           // System.out.println("Despues de eliminar la key: "+bTran +" \n" + transiciones );
                        }
                    
                    }
                    });
        
         List<String> TransicionesGeneran=obtenerKeyMap(transiciones);
        
        List<String> imprimirOrden=ImprimirEnOrden(TransicionesGeneran);
        //Imprimir en orden
        if(contadorParaNoGeneradora==0){
        }else{
        imprimirOrden.stream().forEach(m->System.out.println("Orden de generadoras: " +m));
        imprimirMap(imprimirOrden);
        }
        chomsky.TextArea.setText(chomsky.TextArea.getText() + "\n"+ "\n" +" --> SE ELIMINA VARIABLES INUTILES ..."+ "\n");
        
        //Obtiene los key que todavia existen en el map y validan si tiene una variable inutil
        esVariableInutil(imprimirOrden);
        
        //Recibe como parametros los key del map , lo recorre y validad si es no alcanzable y se borra la transicion
        noAlcanzable(imprimirOrden);
        
        
    }
    
    public void noAlcanzable(List<String> sigma){
        List<String> traNo, tranB= new ArrayList<>();
        tranB= obtenerTransicionesSigma(transiciones);
        //tranB.stream().forEach(r->System.out.println("Lo obtuve los key del map:" +r));
        traNo= transiciones.get(varInicial);
        sigma.stream().forEach(s->System.out.println("Llega a no alcanzable: "+s));
        
        Map<String,Boolean> noAlcanzable= new HashMap<String,Boolean>();
        noAlcanzable= sigma.stream()
                .map(a->a.trim())
                .collect(Collectors.toMap(a->a,a->Boolean.FALSE));
        noAlcanzable.remove(varInicial);
        
        boolean esta=false;
        noAlcanzable.entrySet().stream().forEach(s->System.out.println("Lo que hay en el map de validacion Key: "+s.getKey() + " Value: "+s.getValue()));
        for(String keyTran: sigma){
            if(!keyTran.equals(varInicial)){
                tranB=transiciones.get(varInicial);
                for(String valueTran: tranB){
                    System.out.println("key Prueba1: "+keyTran +" No alcanzable produccion: "+valueTran);
                    String[] transiccionSeparas = valueTran.split("");
                    Arrays.stream(transiccionSeparas).forEach(b->System.out.println("Key: "+ keyTran + " Value: " +b));
                    esta= Arrays.stream(transiccionSeparas).anyMatch(i->i.equals(keyTran));
                    if(esta==true){
                        noAlcanzable.put(keyTran, Boolean.TRUE);
                    }
                    System.out.println("key Prueba2: " + keyTran + " Value: "+esta);
                }   
            }   
        }
        List<String> sonAlcanzables= new ArrayList<>();
        List<String> noSonAlcanzables= new ArrayList<>();

        noAlcanzable.entrySet()
                .stream()
                .forEach(f->{
                    if(f.getValue()==true){
                    sonAlcanzables.add(f.getKey());
                    }else{
                    noSonAlcanzables.add(f.getKey());
                    }
        });
        
        sonAlcanzables.stream().forEach(n->System.out.println("Es alcanzable Key: " + n));
        noSonAlcanzables.stream().forEach(j->System.out.println("No son alcanzables Key: " + j));
        
        noAlcanzable.entrySet().stream().forEach(s->System.out.println("Lo que hay en el map de validacion despues Key: "+s.getKey() + " Value: "+s.getValue()));
        
        List<String> noSonAlcanzablesValidado= esAlcanzable(sonAlcanzables, noSonAlcanzables);
        //System.out.println("Transacciones en no alcanzable \n" +transiciones);
        if(!noSonAlcanzablesValidado.isEmpty()){
        chomsky.TextArea.setText(chomsky.TextArea.getText() + "\n \n" + " -->ELIMINANDO TRANSICIONES NO ALCANZABLES... \n");
        }
        for(String son: noSonAlcanzablesValidado){
            System.out.println("Se elimino transicion no alcanzable: "+ son);
            chomsky.TextArea.setText(chomsky.TextArea.getText() + "\n"  + " Se elimino la transicion " +son + " no es alcanzable" );
            transiciones.remove(son);
        }
        List<String> TransicionesGeneranSigmae=obtenerKeyMap(transiciones);
        List<String> imprimirOrdenSigmae=ImprimirEnOrden(TransicionesGeneranSigmae);
        imprimirMap(imprimirOrdenSigmae);
        
        System.out.println("Map: \n"+transiciones);
    }
    
    //Recoro las otras transicionas para validar si se encuentra en las derivadas
    public List<String> esAlcanzable(List<String> sonAlcanzables, List<String> noSonAlcanzables){
    List<Boolean> esAlcanzableX2 = new ArrayList<>();
    List<String> transicion,guardar= new ArrayList<>();
    if(!esAlcanzableX2.isEmpty()){
        esAlcanzableX2.removeAll(esAlcanzableX2);
    }
    boolean ar=false;
    for(String noAlcanzable: noSonAlcanzables){
        String key= noAlcanzable;
        //System.out.println("Key no alcanzable en el metodo: " +key);
        if(ar==false){
        for(String alcanzable: sonAlcanzables){
            
            transicion=transiciones.get(alcanzable);
            //System.out.println("Key no alcanzable en el metodo primer for: " +key + " alcanzable Key: " + alcanzable);
            for(String value: transicion){
                System.out.println("Key no alcanzable en el metodo primer for: " +key + " alcanzable Key: " + alcanzable + " value: " + value);
                String[] transiccionSeparas = value.split("");
                esAlcanzableX2.add(Arrays.stream(transiccionSeparas).anyMatch(i->i.equals(key)));
            }
        }
        //Si encuentra algun verdadero 
        esAlcanzableX2.stream().forEach(g->System.out.println("Valores para validar No alcanzable Key: " + key + " valor: " +g));
        boolean otraVez = esAlcanzableX2.stream().anyMatch(n->n==true);
        System.out.println("Si es alcanzable o no key: " + key + " value:" + otraVez );
        if(otraVez==true){
            guardar.add(key);
            ar=true;
            System.out.println("Entro y se salio");
        }
        }
    }
    
    for(String h: guardar){
        noSonAlcanzables.remove(h);
        sonAlcanzables.add(h);
        System.out.println("Entro y si es alcanzable: " +h);
        if(noSonAlcanzables.size()>=1){
            System.out.println("Entro a la recursivida");
            noSonAlcanzables.stream().forEach(k->System.out.println("Recursividad no alcanzable key:" + h));
             esAlcanzable(sonAlcanzables, noSonAlcanzables);
         }
    }

    return noSonAlcanzables;
    }
    

    
    //Producciones Nulas
    public void detectarNulas(){
        List<String> transicion,keys= new ArrayList<>();
        List<String> sonNulas2= new ArrayList<>();
        List<String> nulasObtenidas= new ArrayList<>();


        keys= obtenerKeyMap(transiciones);
        boolean verdad,verdad2= false;
        for (String k: keys){
            transicion= transiciones.get(k);
            verdad= transicion.stream().anyMatch(h->h.equals("ε"));
            verdad2= transicion.stream().anyMatch(hr->hr.equals("λ"));
            if(verdad==true || verdad2==true){
                if(verdad==true){
                chomsky.TextArea.setText(chomsky.TextArea.getText() + "\n" +" La transicion "+ k + " es nula por tener la produccion  'ε'");
                }
                if(verdad2==true){
                chomsky.TextArea.setText(chomsky.TextArea.getText() + "\n" +" La transicion "+ k + " es nula por tener la produccion  'λ'");
                }
            sonNulas2.add(k);
            }
        }
        sonNulas2.stream().forEach(j->System.out.println("Son nulas Key:" + j));
        if(!sonNulas2.isEmpty()){
            nulasObtenidas=detectarNulasCombinadas(keys,sonNulas2);
        }
        
        
        nulasObtenidas.stream().forEach(m->System.out.println("Nulas obtenidas Key: " +m));
        /*nulasObtenidas.stream()
                .forEach(m-> chomsky.TextArea.setText(chomsky.TextArea.getText() + "\n" +" La Produccion "+ m + " Es nula"));*/

        eliminarNulas(nulasObtenidas);
    }
    
    public List<String> detectarNulasCombinadas(List<String> keys, List<String> nulas){
        List<String> transi= new ArrayList<>();
        boolean verdad,recur=false;
        int a = nulas.size();
        //System.out.println("Tamaño de list nulas" + a);
        for(String key: keys){
            if(recur==false){
                transi=transiciones.get(key);
                verdad=false;
                for(String tra: transi){
                    if(verdad==false){

                        verdad=estaEnLaTransicionNula(tra,nulas);
                        //System.out.println("La transcion Prueba1 "+key+" Es: " + verdad);
                        if(verdad==true && !key.equals(varInicial)){
                            //System.out.println("Añado al key: " + key);
                        chomsky.TextArea.setText(chomsky.TextArea.getText() + "\n" +" La transicion "+ key + " es nula por tener la produccion " + tra);
                        nulas.add(key);
                        //nulas.stream().forEach(o->System.out.println("Se prueba que es nula: " +o));
                        recur=true;
                        //detectarNulasCombinadas(keys, nulas);
                        }
                    }
                }
            }
        }
        for(String k: nulas){
            keys.remove(k);
        }
        
        //System.out.println("Tamaño de list nulas " + nulas.size());

        nulas.stream().forEach(j->System.out.println("La transicion: " +j+ " es Nula despues de detectar: "  ));
        keys.stream().forEach(i->System.out.println("Despues de remover key:" + i));
        if(nulas.size()>a){
            detectarNulasCombinadas(keys, nulas);
        }
        
        return nulas;
    }
        
    public boolean estaEnLaTransicionNula(String a,List<String> nulas){
        //Separo la produccion
        String[] simbolos= a.split("");
        boolean b=Arrays.stream(simbolos)
                .allMatch(g->estaEnElSimboloNulo(g, nulas));
        System.out.println("La produccion : "+ a + " Es:" +b);
    return b;
    }
    
    public boolean estaEnElSimboloNulo(String simbolo,List<String> nulas){
        boolean a= nulas.stream().anyMatch(b->b.equals(simbolo));
        System.out.println("La letra "+simbolo + " es:" +a);
    return a;
    }
    
    
     //Despues de detectar las nulas empezar a eliminar   
    public void eliminarNulas(List<String> nulasObtenidas){
      
        List<String> tra= obtenerKeyMap(transiciones);
        List<String> produccionesRecorrer=new ArrayList<>();
        
        for(String t: tra){
        mapNuevosSimbolos.put(t, produccionesRecorrer);
        }
        
        chomsky.TextArea.setText(chomsky.TextArea.getText() + "\n" );
        
        boolean esta= false;
        for(String nulaKey: nulasObtenidas){
            System.out.println("Nula obtenida Key: " +nulaKey);
            for(String key: tra){
             produccionesRecorrer=transiciones.get(key);
             //produccionesNuevas.removeAll(produccionesNuevas);
                for(String produccion: produccionesRecorrer){
                    String[] produccionesSeparadas = produccion.split("");
                    esta = Arrays.stream(produccionesSeparadas).anyMatch(p->p.equals(nulaKey));
                    if(esta==true){
                        System.out.println("Si encuentra: " + nulaKey + " en produccion: " + produccion + " de la transcion: "+key);
                    }
                    if(esta==true){
                        String produccionNueva="";
                        for(String separadoValue: produccionesSeparadas){
                            if(!separadoValue.equals(nulaKey)){
                                produccionNueva=produccionNueva+separadoValue;
                            }
                        }
                        System.out.println("Produccion nueva: " + produccionNueva);
                        produccionesNuevas.add(produccionNueva);
                        /*produccionesNuevas.stream().forEach(j->System.out.println("Despues de guardar: " +key + " value: "+j));
                        List<String> jj= Arrays.asList("Gregorio","Perez");
                       /* if(!produccionesNuevas.isEmpty()){
                            //System.out.println("Entro si no esta vacio :" +key);
                            /mapNuevosSimbolos.put(key, produccionesNuevas);
                            //System.out.println("Map: \n"+mapNuevosSimbolos);
                           
                    }*/
                        //producciones.add(produccionNueva);
                    }
                    
                }
                for(String p: produccionesNuevas){
                produccionesRecorrer.add(p);
                }
                produccionesRecorrer.remove(" ");
                produccionesRecorrer.remove("");
                produccionesRecorrer.remove("ε");
                produccionesRecorrer.remove("λ");

                transiciones.put(key, produccionesRecorrer);
                System.out.println("Map prueba: \n" +transiciones);
                 produccionesNuevas.clear();
            }
            
            chomsky.TextArea.setText(chomsky.TextArea.getText() + "\n" +" Se elimina "+ nulaKey+ " por nula ");
            
             List<String> TransicionesGeneranSigma=obtenerKeyMap(transiciones);
             List<String> imprimirOrdenSigma=ImprimirEnOrden(TransicionesGeneranSigma);
             imprimirMap(imprimirOrdenSigma);
        }
       produccionesNuevas.stream().forEach(l->System.out.println("Producciones nuevas Key: " + l));

        System.out.println("Map Nuevos Simbolos \n"+mapNuevosSimbolos );
        System.out.println("Map: \n"+transiciones );
  
        
    }
    
    
    
    public boolean esRecursiva(String key){
        List<String> tra= new ArrayList<>();
        List<Boolean> verda= new ArrayList<>();
        verda.removeAll(verda);
        tra=transiciones.get(key);
        
        for(String b: tra){
               //System.out.println("Key map: " +key+ " transicion: " + b);
               String[] transiccionSeparas = b.split("");
               //Arrays.stream(transiccionSeparas).forEach(f-> System.out.println("Split al string " +f));
                verda.add( Arrays.stream(transiccionSeparas)
                        .anyMatch(s->s.equals(key)));
                        //.allMatch(t-> recorrerTransicion(tra, t));
                //verda.stream().forEach(sx->System.out.println("Validando el boolean en Recursiva: " +sx));
        }
        
        boolean b = verda.stream().allMatch(val->val==true);
        
        return b;
    }
    

    
    
    public List<String> convertirSigma(String a){
        String[] c=a.split("/");
        List<String> g= Arrays.stream(c)
                .map(i-> i)
                .collect(Collectors.toList());
    return g;
    }
    
    public List<String> obtenerTransicionesSigma(Map<String,List<String>> transicion){
        List<String> traSigma = new ArrayList<>();
        transicion.entrySet()
                .stream()
                .forEach(t-> traSigma.add(t.getKey()));
        return traSigma;
    }
    
    public void generadores(String key,List<String> sigma){
        List<Boolean> seEncuentra=new ArrayList<Boolean>();
        seEncuentra.removeAll(seEncuentra);
        for(String transiccion: variablesTerminales){
            //System.out.println("Metodo generadores Transiciones: " +transiccion);
        boolean v=sigma.stream()
                .anyMatch(t->t.equals(transiccion));
        seEncuentra.add(v);
        }
        System.out.println("Metodo generadores Key: " +key);
        boolean c= seEncuentra.stream().anyMatch(t->t==true);
        if(c==false){
                    System.out.println("Metodo generadores si toca borrar Key: " +key);

        borrarNoGeneradoras.add(key);
        }
        
    }
    
    public boolean esGenerador(String transicion){
      boolean v=  variablesTerminales.stream()
                .anyMatch(t->t.equals(transicion) );
      return v;
    }
    
    public List<String> obtenerKeyMap(Map<String, List<String>> sigma){
    List<String> prueba= sigma.entrySet().stream().map(e->e.getKey()).collect(Collectors.toList());
    //prueba.stream().forEach(s->System.out.println("Dentro de prueba " + s ));
    return prueba;
    }
    
    
    
    public List<String> ImprimirEnOrden(List<String> sigma){
        List<String> eliminar = new ArrayList<>();
        List<String> mostrar = new ArrayList<>();

        for(String a: transcionesSigma){
            boolean val= sigma.stream().anyMatch(t->t.equals(a));
            if(!val){
            eliminar.add(a);
            }else{
                mostrar.add(a);
            }
        }
        mostrar.stream().forEach(s->System.out.println("Imprimir VariablesNoTerminales: " +s ));
    return mostrar;
    }
    
    
    
    public List<String> ImprimirEnOrdenVT(List<String> sigma){
        List<String> eliminar = new ArrayList<>();
        List<String> mostrar = new ArrayList<>();

        for(String a: transcionesSigma){
            boolean val= sigma.stream().anyMatch(t->t.equals(a));
            if(!val){
            eliminar.add(a);
            }else{
                mostrar.add(a);
            }
        }
        mostrar.stream().forEach(s->System.out.println("Imprimir VariablesNoTerminales: " +s ));
    return mostrar;
    }
    
    public void imprimirMap(List<String> sigma){
        List<String> prueba=transiciones.get("S");
        //sigma.stream().forEach(s->System.out.println("Probando transiciones : "+s));
        
        List<String> transi= new ArrayList<>();
        List<String> transiInicial= new ArrayList<>();
        transiInicial= transiciones.get(varInicial);

        int con=0;
        int conInicial=0;
        //System.out.println("Tamañno sigma " + sigma.size() );
        contenidoLista="";
        contenidoListaInicial="";
        contenidoListaInicial=contenidoListaInicial + " " + varInicial + "→";
        for (String inicial: transiInicial){
        conInicial++;
        //contenidoListaInicial=contenidoListaInicial + inicial +"/";  
            if(conInicial==transiInicial.size()){
                contenidoLista= contenidoLista + inicial+"\n";
            }else{
                contenidoLista= contenidoLista + inicial + "/" ;
            }
            
        }
        chomsky.TextArea.setText(chomsky.TextArea.getText() + "\n"+ "\n" + contenidoListaInicial);
        
        for(String s: sigma ){
            
            if(!s.equals(varInicial)){
            contenidoLista=contenidoLista+ " " +s + "→";
            transi = transiciones.get(s);
            for(String b: transi){
            con++;
            if(con==transi.size()){
                contenidoLista= contenidoLista + b+"\n";
            }else{
                contenidoLista= contenidoLista + b + "/" ;
            }
            }
            con=0;
            contenidoLista= contenidoLista;
        }
        //System.out.println("Contador " + con);
                //System.out.println("Lo que hay en contenido Lista: "+contenidoLista);
        
        }
        chomsky.TextArea.setText(chomsky.TextArea.getText()  + contenidoLista);
    }
    
    public void imprimirMapFinal(List<String> sigma){
        List<String> prueba=transiciones.get("S");
        //sigma.stream().forEach(s->System.out.println("Probando transiciones : "+s));
        
        List<String> transi= new ArrayList<>();
        List<String> transiInicial= new ArrayList<>();
        transiInicial= transicionesfinal.get(varInicial);

        int con=0;
        int conInicial=0;
        //System.out.println("Tamañno sigma " + sigma.size() );
        contenidoLista="";
        contenidoListaInicial="";
        contenidoListaInicial=contenidoListaInicial + " " + varInicial + "→";
        for (String inicial: transiInicial){
        conInicial++;
        //contenidoListaInicial=contenidoListaInicial + inicial +"/";  
            if(conInicial==transiInicial.size()){
                contenidoLista= contenidoLista + inicial+"\n";
            }else{
                contenidoLista= contenidoLista + inicial + "/" ;
            }
            
        }
        chomsky.TextArea.setText(chomsky.TextArea.getText() + "\n"+ "\n" + contenidoListaInicial);
        
        for(String s: sigma ){
            
            if(!s.equals(varInicial)){
            contenidoLista=contenidoLista+ " " +s + "→";
            transi = transicionesfinal.get(s);
            for(String b: transi){
            con++;
            if(con==transi.size()){
                contenidoLista= contenidoLista + b+"\n";
            }else{
                contenidoLista= contenidoLista + b + "/" ;
            }
            }
            con=0;
            contenidoLista= contenidoLista;
        }
        //System.out.println("Contador " + con);
                //System.out.println("Lo que hay en contenido Lista: "+contenidoLista);
        
        }
        chomsky.TextArea.setText(chomsky.TextArea.getText()  + contenidoLista);
        
        int conVariables = variablesFinales.size();
        
        String contenidoVariables="";
        List<String> varFinales= new ArrayList<>();
        for(int ia=1; ia<=conVariables;ia++){
            String key="V"+subscript(ia);
            varFinales=variablesFinales.get(key);
            contenidoVariables=contenidoVariables+ " " +key + "→";
            for(String b: varFinales){
            con++;
            if(con==transi.size()){
                contenidoVariables= contenidoVariables + b+"\n";
            }else{
                contenidoVariables= contenidoVariables + b + "\n" ;
            }
            }
            con=0;
            contenidoVariables= contenidoVariables;
        }
        
        chomsky.TextArea.setText(chomsky.TextArea.getText()  + contenidoVariables);
        
        
        
        int conVariablesT = variableTerminal.size();
        
        String contenidoVariablesT="";
        List<String> varFinalesT= new ArrayList<>();
       String varT="";
        for(String g: variablesTerminales){
            varT=variableTerminal.get(g);
            contenidoVariablesT=contenidoVariablesT+ " " +g + "→";

            contenidoVariablesT= contenidoVariablesT + varT+"\n";
            
            contenidoVariablesT= contenidoVariablesT;
        
        }
        
        chomsky.TextArea.setText(chomsky.TextArea.getText()  + contenidoVariablesT);
        
    }
    
    
    public void esVariableInutil(List<String> vnt){
        List<String> variablesNtYT= Stream
                .concat(vnt.stream(), variablesTerminales.stream())
                .collect(Collectors.toList());
        List<String> transccionesEliminar=new ArrayList<>();
        List<String> transicionesValues=new ArrayList<>();  
         for(String tran: vnt){
                    System.out.println("Imprimir bien:"+tran.equals("B"));
                }
        variablesNtYT.forEach(g->System.out.println("Variables: "+g));
        vnt.stream().forEach(ss->System.out.println("Key Prueba3:"+ss));
        //Recorer el map para validar variables inutiles
        for(String key: vnt){
            transicionesValues=transiciones.get(key);
            transicionesValues.stream().forEach(ss->System.out.println("Key Prueba4: "+key.trim() + " Value: "+ss));
            //Recoro la lista con las transicciones de cada key
            for(String b: transicionesValues){
               System.out.println("Key map: " +key+ " transicion: " + b);
               String[] transiccionSepara = b.split("");
               //Arrays.stream(transiccionSepara).forEach(f-> System.out.println("Split al string " +f));
                boolean encontro = Arrays.stream(transiccionSepara)
                        .allMatch(t-> EstaEnVtVnt(variablesNtYT, t));
                System.out.println("Encontro Key:"+key+ " -Value: "+b+" " +encontro); 
                if(!encontro){
                transccionesEliminar.add(b);
                chomsky.TextArea.setText(chomsky.TextArea.getText() + "\n" +" " +"Se elimina de la transicion " + key + " la variable inutil: "+b );

                }
            }
            if(!transccionesEliminar.isEmpty()){
             for(String borrar: transccionesEliminar){
                transicionesValues.remove(borrar);

             }
             transiciones.put(key, transicionesValues);
            }
        }
        //Key del map para comparar con el original
        //List<String> imprimirOrden=ImprimirEnOrden(vnt);
        
        //imprimirOrden.stream().forEach(m->System.out.println("Orden de generadoras: " +m));
        imprimirMap(vnt);
        transccionesEliminar.stream().forEach(t->System.out.println("Transicion a eliminar:" +t));

    }
    
    public boolean EstaEnVtVnt(List<String> variables, String dato){
        boolean a=variables.stream().anyMatch(t-> dato.equals(t));
        System.out.println("Dato:" +dato+ " Resultado: " + a);
        return a;
    }
    
    public void identificarProduccionesUnitarias(){
        List<String> keys = obtenerKeyMap(transiciones);
        List<String> keysRecorrer = keys;
        List<String> transicionis=new ArrayList<>();
        List<String> unitarias=new ArrayList<>();

        boolean a=false;
        for(String key: keys){
            transicionis= transiciones.get(key);
            a=false;
            for(String produccion: transicionis){
                //if(a==false){
                   a=keysRecorrer.stream().anyMatch(k->k.equals(produccion));
                   if(a==true){
                       System.out.println("la Transicion: " +key + " tiene una produccion unitaria: " + produccion);
                       unitarias.add(key);
                   }
                //}
            }
            
        }
        unitarias=unitarias.stream().distinct().collect(Collectors.toList());
        unitarias.stream().forEach(t->System.out.println("Es unitaria la transicion: "+t));
        reemplazarUnitaria(unitarias,keys);
    }
    
    public void reemplazarUnitaria(List<String> unitarias,List<String> keys){
        List<String> producciones=new ArrayList<>();
        
        List<String> produccionesSigma=new ArrayList<>();
        List<String> produccionesSigmaU=new ArrayList<>();
        List<String> recorrers=new ArrayList<>();
        List<String> produccionesSigmaK=new ArrayList<>();
        List<String> sigmaKeys=obtenerKeyMap(transiciones);

        List<String> produccionesSigmaRecorrer=new ArrayList<>();
        List<String> eliminarUnitarias=new ArrayList<>();
        boolean a,b,c,d,bidi,j,i= false;
        String fs="";
        for(String ke: sigmaKeys){
            System.out.println("KEY SIGMA: "+ke); 
            for(String unitaria: unitarias){
                producciones=transiciones.get(unitaria);
                j=producciones.stream().anyMatch(k->k.equals(ke));
                if(j==true){
                    for(String produccion: producciones){
                        //obtengo la produccion unitaria de la transicion
                        if(produccion.equals(ke)){
                            System.out.println("PRODUCCION : " + produccion + " de la transicion "+ke);

                            a=keys.stream().anyMatch(p->p.equals(produccion));
                            fs=produccion;
                            if(a==true){
                                //valido q la produccion no tenga tampoco una unitaria
                                b=unitarias.stream().anyMatch(p->p.equals(produccion));
                                if(b==false){
                                    i=true;
                                    produccionesSigmaRecorrer= transiciones.get(produccion);
                                    for(String p: produccionesSigmaRecorrer){
                                        produccionesSigma.add(p);
                                    }
                                }
                            }
                        }
                    }
                }
                //if(i==true){
                    if(!produccionesSigma.isEmpty()){

                    for(String pAnadir: produccionesSigma){
                     producciones.add(pAnadir);
                    }
                    producciones=producciones.stream().distinct().collect(Collectors.toList());
                    producciones.remove(ke);
                    chomsky.TextArea.setText(chomsky.TextArea.getText() + "\n Reemplazando: " + fs + " de la transicion "+unitaria);
                    
                    
                    
                    

                    transiciones.put(unitaria, producciones);
                    produccionesSigma.clear();
                    System.out.println("Map despues de añadir unitaria \n"+transiciones);
                    }
                //}
                
                
            }
            if(i==true){
                String lista=imprimirListString(fs);
                chomsky.TextArea.setText(chomsky.TextArea.getText() + "\n " + lista);
                List<String> TransicionesGeneranSigma=obtenerKeyMap(transiciones);
                    List<String> imprimirOrdenSigma=ImprimirEnOrden(TransicionesGeneranSigma);
                    imprimirMap(imprimirOrdenSigma);
                }
            //chomsky.TextArea.setText(chomsky.TextArea.getText() + "\n ");
            i=false;
        }
        
        //Valido q la transiccion no tiene unitarias y la añado a la lista para eliminarala de unitarias
        for(String unitaria: unitarias){
            producciones=transiciones.get(unitaria);
            System.out.println("Entro al final " + unitaria);
            boolean be= producciones.stream().anyMatch(g->borrarUnitaria(g, keys));
            System.out.println("Unitaria: " + unitaria + " Value es: " +be);
            if(be==false){
                System.out.println("Entro a eliminar:" +unitaria);
                eliminarUnitarias.add(unitaria);
            }
        }
        
        //Elimino de unitarias
        for(String unitaria: eliminarUnitarias){
            System.out.println("Se elimina unitaria:" + unitaria);
            unitarias.remove(unitaria);    
        }
        
        //Reemplzar unitarias si es bidireccional
        List<String> produccionesUnitaria=new ArrayList<>();
        List<String> produccionesKey=new ArrayList<>();
        List<String> produccionesSigmaRecorrerKey=new ArrayList<>();
        List<String> produccionesSigmaRecorrerUnitaria=new ArrayList<>();
        List<String> produccionesSigma2=new ArrayList<>();
        List<String> produccionesSigma3=new ArrayList<>();
        boolean r=false;
        boolean p=false;
            String keyUnitaria= "";
            String keyProduccion="";
        for(String unitaria: unitarias){
            producciones=transiciones.get(unitaria);
            
            if(r==false){
                for(String produccion: producciones){
                  //d=keys.stream().anyMatch(p->p.equals(produccion));

                  for(String key: keys){
                      if(p==false){
                        d=produccion.equals(key);
                        if(d==true){
                            bidi=esBidireccional(key, unitaria);
                            if(bidi==true){
                              keyUnitaria= unitaria;
                              keyProduccion=key;
                                System.out.println("Unitaria: " + unitaria + " esta en: " + key);
                                System.out.println("Key: " + key + " tiene unitaria: " + unitaria);
                              p=true;
                              r=true;
                              produccionesUnitaria=transiciones.get(unitaria);
                              //produccionesUnitaria.remove(produccion);
                              produccionesKey=transiciones.get(produccion);
                              //produccionesKey.remove(unitaria);
                              produccionesSigmaRecorrerKey= transiciones.get(produccion);
                              for(String pr: produccionesUnitaria){
                                  produccionesSigmaU.add(pr);
                              }
                              for(String pk: produccionesKey){
                                  produccionesSigmaK.add(pk);
                              }
                            }
                        }
                      }
                  }
                }
               
            }}
        
         if(!produccionesSigmaU.isEmpty() && !produccionesSigmaK.isEmpty()){
                    System.out.println("Unitaria en validaacion "+ keyUnitaria);
                    System.out.println("Key en validaacion "+ keyProduccion);
                    chomsky.TextArea.setText(chomsky.TextArea.getText() + "\n Reemplazando: " + keyProduccion + " de la transicion "+keyUnitaria);
                    chomsky.TextArea.setText(chomsky.TextArea.getText() + "\n Reemplazando: " + keyUnitaria + " de la transicion "+keyProduccion);
                    String lista=imprimirListString(keyUnitaria);
                    chomsky.TextArea.setText(chomsky.TextArea.getText() + "\n " + lista);
                    String lista2=imprimirListString(keyProduccion);
                    chomsky.TextArea.setText(chomsky.TextArea.getText() + "\n " + lista2);
                    List<String> obtenerProducciones= transiciones.get(keyUnitaria);
                    //producciones.clear();
                    producciones.stream().forEach(gg->System.out.println("Producciones de unitarias: "+gg));
                    produccionesSigmaK.stream().forEach(rr->System.out.println("Producciones de key: "+rr));
                    for(String pAnadir: produccionesSigmaK){
                     obtenerProducciones.add(pAnadir);
                    }
                    //producciones.remove(keyUnitaria);
                    obtenerProducciones=obtenerProducciones.stream().distinct().collect(Collectors.toList());
                    obtenerProducciones.remove(keyProduccion);
                    obtenerProducciones.remove(keyUnitaria);
                    List<String> prueba= obtenerProducciones;
                    prueba.stream().forEach(gr->System.out.println("Producciones de  Prueba despues de añadir: "+gr));
                    List<String> re= Arrays.asList("Gregorio", "Perez");
                    transiciones.put(keyUnitaria, prueba);
                    
                    //Ahora par keyProduccion
                    List<String> obtenerProduccionesKey= transiciones.get(keyProduccion);
                    produccionesSigmaU.stream().forEach(rr->System.out.println("Producciones de key: "+rr));
                    for(String pAnadir: produccionesSigmaU){
                     obtenerProduccionesKey.add(pAnadir);
                    }
                    
                    obtenerProduccionesKey=obtenerProduccionesKey.stream().distinct().collect(Collectors.toList());
                    obtenerProduccionesKey.remove(keyUnitaria);
                    obtenerProduccionesKey.remove(keyProduccion);
                    List<String> prueba2= obtenerProduccionesKey;
                    prueba2.stream().forEach(gr->System.out.println("Producciones de  Prueba key despues de añadir: "+gr));
                    transiciones.put(keyProduccion, prueba2);
                    producciones.clear();
                    
                    produccionesSigma.clear();
                    System.out.println("Map despues de añadir unitaria \n"+transiciones);
                    produccionesSigmaU.clear();
                    produccionesSigmaK.clear();
                    
                    List<String> TransicionesGeneranSigma=obtenerKeyMap(transiciones);
                    List<String> imprimirOrdenSigma=ImprimirEnOrden(TransicionesGeneranSigma);
                    imprimirMap(imprimirOrdenSigma);
                
                    System.out.println("Map final: \n" +transiciones);
                }
         
         //Valido q la transiccion no tiene unitarias y la añado a la lista para eliminarala de unitarias
        for(String unitaria: unitarias){
            producciones=transiciones.get(unitaria);
            System.out.println("Entro al final " + unitaria);
            boolean be= producciones.stream().anyMatch(g->borrarUnitaria(g, keys));
            System.out.println("Unitaria: " + unitaria + " Value es: " +be);
            if(be==false){
                System.out.println("Entro a eliminar:" +unitaria);
                eliminarUnitarias.add(unitaria);
            }
        }
        
        //Elimino de unitarias
        for(String unitaria: eliminarUnitarias){
            System.out.println("Se elimina unitaria:" + unitaria);
            unitarias.remove(unitaria);    
        }
        
        if(!unitarias.isEmpty()){
            reemplazarUnitaria(unitarias, keys);
        }
    
    }
    
    public void normalizar(){
    List<String> keys= obtenerKeyMap(transiciones);
        System.out.println("Map: \n" + transiciones);
    List<String> varInicialProducciones= transiciones.get(varInicial);
    List<String> nuevasProducciones=new ArrayList<>();
    int sumar=1;

    chomsky.TextArea.setText(chomsky.TextArea.getText() + "\n \n" + " Normalizando variables de la transicion "+ varInicial + "\n"  );
    boolean gr=false;
        imprimirTransiciones(varInicial, transiciones);
    for(String produccion: varInicialProducciones){
        String[] variables= produccion.split("");
        System.out.println("tamaño produccion: " + produccion + " valor: " +variables.length );
        
        if( variables.length<=2  ){
            String var="";
            for(String variable: variables){
             boolean esVt=variablesTerminales.stream().anyMatch(g-> g.equals(variable));
             if(esVt){
                 String a=variableTerminal.get(variable);
                 var=var+a;
             }else{
                var=var+variable;
             }
            }
            chomsky.TextArea.setText(chomsky.TextArea.getText() + " " + produccion + "→" + var + "\n");
            System.out.println("Var: "+ var);
            nuevasProducciones.add(var);
        }else{
          String var="";
          int d=0;
          int c=0;
          boolean f=false;
          String[] enviar= new String[variables.length-1];
            for(String variable: variables){
             if(c==0){
                boolean esVt=variablesTerminales.stream().anyMatch(g-> g.equals(variable));
                 System.out.println("Suma al inicio "+sumar);
                if(esVt){
                    String a=variableTerminal.get(variable);
                    var=a+"V"+subscript(sumar);
                }else{
                   var=variable+"V"+subscript(sumar);
                }
                
                gr=true;
                
             }else{
                 enviar[d]=variable;
                 d++;
                 f=true;
             }
             c++;
            }
            chomsky.TextArea.setText(chomsky.TextArea.getText() + " " + produccion + "→" + var + "\n");
            if(f==true){
                sumar=sumas(enviar,sumar);
            }
            /*if(gr==false){
                    sumar++;
                }else{
                
                }*/
            System.out.println("Var: "+ var + " suma es "+ sumar);
            nuevasProducciones.add(var);
          
        }
        transicionesfinal.put(varInicial, nuevasProducciones);
  
    }
    imprimirTransiciones(varInicial, transicionesfinal);
    chomsky.TextArea.setText(chomsky.TextArea.getText() +  "\n");

    
        System.out.println("Map de inicial: \n" +transicionesfinal);
    
    //validar desde aqui para las keys
    //nuevasProducciones.clear();
    
   
    keys.stream().forEach(hh->System.out.println("Keys to:"+ hh));
    //List<String> nuevasProducciones2=new ArrayList<>();
    int su=0;
    keys.remove(varInicial);
    List<String> keysb= Arrays.asList("A","B");
    for(String key: keys){
        chomsky.TextArea.setText(chomsky.TextArea.getText() + "\n" + " Normalizando variables de la transicion "+ key + "\n"  );
        imprimirTransiciones(key, transiciones);
        su++;
        String suS=String.valueOf(su);
        List<String> nuevasProducciones2=new ArrayList<>();
        nuevasProducciones2.stream().forEach(nm->System.out.println("Producciones 2 "+ nm));
        nuevasProducciones2.removeAll(nuevasProducciones2);
        nuevasProducciones2.stream().forEach(nm->System.out.println("Producciones 2 despues de remover "+ nm));

        if(!key.equals(varInicial)){
            System.out.println("Entro key if: " +key);
            varInicialProducciones=transiciones.get(key);
            gr=false;
            for(String produccion: varInicialProducciones){
                String[] variables= produccion.split("");
                System.out.println("tamaño produccion: " + produccion + " valor: " +variables.length );

                if( variables.length<=2  ){
                    String var="";
                    for(String variable: variables){
                     boolean esVt=variablesTerminales.stream().anyMatch(g-> g.equals(variable));
                     if(esVt){
                         String a=variableTerminal.get(variable);
                         var=var+a;
                     }else{
                        var=var+variable;
                     }
                      System.out.println("Llega a guardar if produccion: " +var);
                    }
                    chomsky.TextArea.setText(chomsky.TextArea.getText() + " " + produccion + "→" + var + "\n");
                    System.out.println("Var: "+ var);
                    nuevasProducciones2.add(var);
                }else{
                  String var="";
                  int d=0;
                  int c=0;
                  boolean f=false;
                  String[] enviar= new String[variables.length-1];
                    for(String variable: variables){
                     if(c==0){
                        boolean esVt=variablesTerminales.stream().anyMatch(g-> g.equals(variable));
                         System.out.println("Suma al inicio "+sumar);
                        if(esVt){
                            String ar=variableTerminal.get(variable);
                            var=ar+"V"+subscript(sumar);
                        }else{
                           var=variable+"V"+subscript(sumar);
                        }
                         System.out.println("Llega a guardar else produccion: " +var);

                        gr=true;

                     }else{
                         enviar[d]=variable;
                         d++;
                         f=true;
                     }
                     c++;
                    }
                    chomsky.TextArea.setText(chomsky.TextArea.getText() + " " + produccion + "→" + var + "\n");
                    if(f==true){
                        sumar=sumas(enviar,sumar);
                    }
                   
                    
                    System.out.println("Var: "+ var + " suma es "+ sumar);
                    nuevasProducciones2.add(var);
                }
                
                

            }
            for(String gre: nuevasProducciones2){
                    System.out.println("Guardar en el map Key: "+key + " produccion " +gre);
                }
            
            //nuevasProducciones2.clear();
        }
        
        transicionesfinal.put(key, nuevasProducciones2);
        imprimirTransiciones(key, transicionesfinal);
        //nuevasProducciones.clear();
    }
    
            System.out.println("Map final transacciones \n" + transicionesfinal);
         //Sirve con cualquier map  
        List<String> TransicionesGeneranSigma4=obtenerKeyMap(transicionesfinal);
        TransicionesGeneranSigma4.stream().forEach(hh->System.out.println("Keys del map final " + hh));
        //List<String> imprimirOrdenSigma=ImprimirEnOrden(TransicionesGeneranSigma4);
        chomsky.TextArea.setText(chomsky.TextArea.getText()  + "\n \n" + " --> FORMA NORMAL DE CHOMSKY REEMPLAZANDO ....");
        imprimirMapFinal(TransicionesGeneranSigma4);

    }
    
    public int sumas(String[] variables,int suma){
        List<String> probar = Arrays.stream(variables).collect(Collectors.toList());
        List<String> nuevasProducciones=new ArrayList<>();
        String re= "";
        for(String l: variables){
            re=re+l;
        }
        if(entro==false){
        
        }
        System.out.println("LLega a suma: " + re);
        System.out.println("Suma llega: " +suma);
        System.out.println("Tamaño variables length: "+ variables.length);
        int sumar= suma;
        int a = variables.length;
        String var="";
        int d=0;
        int cc=0;
        boolean r=false;
        boolean rx=false;
        String[] enviar= new String[variables.length-1];
        for(String v: variables){
            System.out.println("Entra y suma a variable "+ suma);
            if(a==2){
                boolean esVt=variablesTerminales.stream().anyMatch(g-> g.equals(v)); 
                if(rx==false){
                    contadorNormalizaar++;
                    suma++;
                     System.out.println("Entra y suma "+ suma);
                }
                if(esVt){
                 String c=variableTerminal.get(v);
                 var=var+c;
                 rx=true;
                 
                }else{
                    var=var+v;
                    rx=true;
                    
                }
                
            }
            if(a>2){
                
                boolean f=false;
                    if(cc==0){
                        boolean esVt=variablesTerminales.stream().anyMatch(g-> g.equals(v));
                        System.out.println("haber q sale V"+subscript(sumar-1)+" de la variable: " +v);
                        if(rx==false){
                            contadorNormalizaar++;
                            suma++;
                             System.out.println("Entra y suma "+ suma);
                             
                        }
                        if(esVt){
                            String ac=variableTerminal.get(v);
                            var=ac+"V"+subscript(suma);
                            rx=true;
                            entro=true;
                        }else{
                           var=v+"V"+subscript(suma);
                           rx=true;
                           entro=true;
                        }
                        System.out.println("Dentro del if Var: " +var);
                    cc++;
                    
                    }else{
                        enviar[d]=v;
                        d++;
                        r=true;
                    }
                   
            }
        }
        System.out.println("Var: "+var + " en probar para añadir: " + "V"+subscript(contadorNormalizaar));
        nuevasProducciones.add(var);
        chomsky.TextArea.setText(chomsky.TextArea.getText() + " " + "V"+subscript(contadorNormalizaar) + "→" + var + "\n");
        variablesFinales.put("V"+subscript(contadorNormalizaar), nuevasProducciones);
        //suma=suma-1;
        System.out.println("Suma se envia: " +suma);
        
        if(r==true){
            for(String e:enviar){
                System.out.println("Enviar tiene: "+e);
            }
            
            sumas(enviar, suma);
        }
        //nuevasProducciones.clear();
        
       return contadorNormalizaar+1;
    }
    
    public void imprimirTransiciones(String key, Map<String,List<String>> transicion){
        String a=key +"→";
        int cont = 0;
        List<String> transicions=new ArrayList<>();
        transicions=transicion.get(key);
        for(String p: transicions){
            cont++;
        //contenidoListaInicial=contenidoListaInicial + inicial +"/";  
            if(cont==transicions.size()){
                a= a + p;
            }else{
                a= a + p + "/" ;
            } 
        }
       chomsky.TextArea.setText(chomsky.TextArea.getText() + " " +a + "\n");
    }
    
    public String imprimirListString(String key){
        String a=key +"→";
        int cont = 0;
        List<String> transicions=new ArrayList<>();
        transicions=transiciones.get(key);
        for(String p: transicions){
            cont++;
        //contenidoListaInicial=contenidoListaInicial + inicial +"/";  
            if(cont==transicions.size()){
                a= a + p;
            }else{
                a= a + p + "/" ;
            } 
        }
        return a;
    }
    
    public boolean borrarUnitaria(String unitaria,List<String> keys){
        boolean a = keys.stream().anyMatch(s->s.equals(unitaria));
        return a;
    }
    
    
    public boolean esBidireccional(String key, String keyUnitaria){
        List<String> transicions=new ArrayList<>();
        boolean a;
        transicions= transiciones.get(key);
        a=transicions.stream().anyMatch(p->p.equals(keyUnitaria));
        return a;
                
    }
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Vista.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Vista.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Vista.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Vista.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Vista().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextField InputVariablesTerminales;
    private javax.swing.JTextArea TextSigma;
    private javax.swing.JTextField TextVariableInicial;
    private javax.swing.JTextField TextVariablesTerminales;
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton3;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JScrollPane jScrollPane1;
    // End of variables declaration//GEN-END:variables
}
