/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package Main;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.swing.JOptionPane;

/**
 *
 * @author GREGORIO
 */
public class Vista extends javax.swing.JFrame {

    /**
     * Creates new form Vista
     */
    
    Chomsky chomsky=new Chomsky();
    List<String> variablesNoTerminales=new ArrayList<>();
    List<String> variablesTerminales=new ArrayList<>();
    List<String> transcionesSigma= new ArrayList<>();
     Map<String,List<String>> transiciones=new HashMap<String,List<String>>();
     List<String> borrarNoGeneradoras=new ArrayList<>();
     String varInicial="";
     String contenidoLista="";
     String contenidoListaInicial="";
     String[] cadenaSplit= new String[4];
     List<String> probando = new ArrayList<>();
     int contadorParaNoGeneradora=0;
     List<String> produccionesNuevas = new ArrayList<>();
     Map<String,List<String>> mapNuevosSimbolos= new HashMap<>();



    public Vista() {
        initComponents();
        this.setLocationRelativeTo(null);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        InputVariablesTerminales = new javax.swing.JTextField();
        jButton1 = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        TextVariablesTerminales = new javax.swing.JTextField();
        TextVariableInicial = new javax.swing.JTextField();
        jLabel4 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        TextSigma = new javax.swing.JTextArea();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        InputVariablesTerminales.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                InputVariablesTerminalesActionPerformed(evt);
            }
        });

        jButton1.setText("Convertir");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jLabel1.setFont(new java.awt.Font("Calibri", 1, 24)); // NOI18N
        jLabel1.setText("Gramatica Chomsky");

        jLabel2.setText("Variables no Terminales");

        jLabel3.setText("Variables Terminales");

        TextVariablesTerminales.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                TextVariablesTerminalesActionPerformed(evt);
            }
        });

        TextVariableInicial.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                TextVariableInicialActionPerformed(evt);
            }
        });

        jLabel4.setText("Variable Inicial");

        jLabel5.setText("Sigma");

        TextSigma.setColumns(20);
        TextSigma.setRows(5);
        jScrollPane1.setViewportView(TextSigma);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGap(20, 20, 20)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel4)
                    .addComponent(jLabel5)
                    .addComponent(jLabel3)
                    .addComponent(jLabel2))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                    .addComponent(InputVariablesTerminales, javax.swing.GroupLayout.DEFAULT_SIZE, 256, Short.MAX_VALUE)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                        .addComponent(TextVariablesTerminales)
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 256, Short.MAX_VALUE)
                        .addComponent(TextVariableInicial)))
                .addGap(22, 22, 22))
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(100, 100, 100)
                        .addComponent(jLabel1))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(137, 137, 137)
                        .addComponent(jButton1)))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(InputVariablesTerminales, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel2))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(TextVariablesTerminales, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel3))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(TextVariableInicial, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel4))
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(18, 18, 18)
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 166, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(31, 31, 31)
                        .addComponent(jLabel5)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                .addComponent(jButton1)
                .addGap(6, 6, 6))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void InputVariablesTerminalesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_InputVariablesTerminalesActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_InputVariablesTerminalesActionPerformed

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        //this.setVisible(false);
        borrarNoGeneradoras.removeAll(borrarNoGeneradoras);
        if(!borrarNoGeneradoras.isEmpty()){
        borrarNoGeneradoras.stream().forEach(ss->System.out.println("Imprime no generadora "+ ss));
        }
        transcionesSigma.removeAll(transcionesSigma);
        variablesTerminales.removeAll(variablesTerminales);
        variablesNoTerminales.removeAll(variablesNoTerminales);
        
        if(!variablesNoTerminales.isEmpty()){
            for(String b: variablesTerminales){
                transiciones.remove(b);
            }
        }
        
        chomsky.TextArea.setText("");
        chomsky.setVisible(false);
        String varNoTer= InputVariablesTerminales.getText();
        variablesNoTerminales= new ArrayList<String>(Arrays.asList(varNoTer.split(",")));
        variablesNoTerminales.stream()
                            .forEach(vt -> {
                                            esString(vt.trim(),"La variable no terminal ");
                                            System.out.println("variable no terminal: " +vt);});
        String varTer= TextVariablesTerminales.getText();
        variablesTerminales= new ArrayList<String>(Arrays.asList(varTer.split(",")));
        variablesTerminales.add("ε");
        variablesTerminales.add("λ");
        variablesTerminales.stream()
                            .forEach(vt -> {
                                            noEsNumero(vt.trim(),"La variable terminal ");
                                            System.out.println("variable terminal: " + vt);});
        varInicial = TextVariableInicial.getText();
        boolean estaVarInicial = variablesNoTerminales.stream()
                                .anyMatch(vnt-> vnt.equals(varInicial));
        
        if(estaVarInicial==false){
            JOptionPane.showMessageDialog(rootPane, "La variable inicial " +varInicial +" no se encuentra en las variables no terminales");
        }else{
        System.out.println(estaVarInicial);
        
        //
        
        chomsky.setString(TextSigma.getText());
        
        transiciones=null;
        
        //Asignar sigma a un map
                String a;
        /*Map<String, List<String>> transiciones =
                Arrays.stream(TextSigma.getText().split(","))
                //.map(i-> i.split("/"))
                //.forEach(System.out::println)
                .map(i-> i.split("→"))
                .collect(Collectors.groupingBy(entry->entry[0],v->convertirSigma(v[1])));
                /*.collect(Collectors.groupingBy(entry-> entry[0],
                        Collectors.mapping(entry->convertirSigma(entry[1]),
                                Collectors.toList() )));*/
        

        //transiciones.entrySet().stream().forEach(e->System.out.println(e.getKey() + " : " + e.getValue()));
        
        chomsky.TextArea.setText(" Sigma sus Transiciones ...."  );
        guardarTransiciones(TextSigma.getText());
        
        chomsky.TextArea.setText(chomsky.TextArea.getText() + "\n"+ "\n" +" Se elimina producciones nulas"+ "\n");
        detectarNulas();
        
        chomsky.setVisible(true);
        
        }
        
        
        /*if(!validarString(InputVariablesTerminales.getText().trim())){
            JOptionPane.showMessageDialog(rootPane, "LOS DATOS NO SON VALIDOS");
        }*/
    }//GEN-LAST:event_jButton1ActionPerformed

    private void TextVariablesTerminalesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_TextVariablesTerminalesActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_TextVariablesTerminalesActionPerformed

    private void TextVariableInicialActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_TextVariableInicialActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_TextVariableInicialActionPerformed

    public void esString(String datos,String mensaje){
        if(!datos.matches("[a-zA-Z]")){
            JOptionPane.showMessageDialog(rootPane, mensaje + datos  + " no esta permitida");
        }
    }
    public void noEsNumero(String datos,String mensaje){
        if(!datos.matches("[0-9]") && !datos.matches("[λε]") && !datos.matches("[a-z]")){
            JOptionPane.showMessageDialog(rootPane, mensaje + datos  + " no esta permitido");
        }
    }
    
    public void guardarTransiciones(String sigma){
        String[] obtenerTransiciones=sigma.split(",");
        String a=Arrays.toString(obtenerTransiciones);
        List<String> az=Arrays.stream(obtenerTransiciones)
                .map(t->t=t.trim())
                .collect(Collectors.toList());
       //az.stream().forEach(fs->System.out.println("Probando como ingresa"+fs));
       
       transiciones= az.stream()
               .map(tra-> tra.split("→"))
               .collect(Collectors.toMap(entry-> entry[0].trim(),entry-> convertirSigma(entry[1])));    
        System.out.println("La transcion del Map: \n" +transiciones);

        transcionesSigma=obtenerTransicionesSigma(transiciones);
        
        //Aca imprime en sigma
       //az.stream().forEach(x->chomsky.TextArea.setText(chomsky.TextArea.getText()+ "\n" + x ));
        List<String> TransicionesGeneranSigma=obtenerKeyMap(transiciones);
        List<String> imprimirOrdenSigma=ImprimirEnOrden(TransicionesGeneranSigma);
        imprimirMap(imprimirOrdenSigma);
        
        //transcionesSigma.stream().forEach(atr->System.out.println("Transiciones Sigma: "+atr));

        //asignar a generadoras las q no son
        transiciones.entrySet()
                .stream()
                .forEach(e-> generadores(e.getKey(),e.getValue()));
        
        
        //System.out.println("Index de " + borrarNoGeneradoras.indexOf("SS"));
        contadorParaNoGeneradora= 0;
        borrarNoGeneradoras.stream()
                .forEach(bTran-> {
                    System.out.println(bTran);
                    System.out.println(varInicial);
                    if(!bTran.equals(varInicial)){
                        System.out.println("Probando q llega en no generadoras: "+ bTran);
                        if(esRecursiva(bTran)){
                            contadorParaNoGeneradora++;
                          if(contadorParaNoGeneradora==1){
                              chomsky.TextArea.setText(chomsky.TextArea.getText() +"\n" + "\n"  +" Eliminando no generadoras" +"\n");
                          }
                          
                          chomsky.TextArea.setText(chomsky.TextArea.getText()+ "\n"+" La transicion " +  bTran +" no es generadora");
                          
                            //System.out.println("Eliminar despues de validar recursivida: " +bTran);
                          transiciones.remove(bTran);
                           // System.out.println("Despues de eliminar la key: "+bTran +" \n" + transiciones );
                        }
                    
                    }
                    });
        
         List<String> TransicionesGeneran=obtenerKeyMap(transiciones);
        
        List<String> imprimirOrden=ImprimirEnOrden(TransicionesGeneran);
        //Imprimir en orden
        if(contadorParaNoGeneradora==0){
        }else{
        imprimirOrden.stream().forEach(m->System.out.println("Orden de generadoras: " +m));
        imprimirMap(imprimirOrden);
        }
        chomsky.TextArea.setText(chomsky.TextArea.getText() + "\n"+ "\n" +" Se elimina Variables inutiles"+ "\n");
        esVariableInutil(imprimirOrden);
        
        
        noAlcanzable(imprimirOrden);
        
        
    }
    
    public void noAlcanzable(List<String> sigma){
        List<String> traNo, tranB= new ArrayList<>();
        tranB= obtenerTransicionesSigma(transiciones);
        //tranB.stream().forEach(r->System.out.println("Lo obtuve los key del map:" +r));
        traNo= transiciones.get(varInicial);
        sigma.stream().forEach(s->System.out.println("Llega a no alcanzable: "+s));
        
        Map<String,Boolean> noAlcanzable= new HashMap<String,Boolean>();
        noAlcanzable= sigma.stream()
                .map(a->a.trim())
                .collect(Collectors.toMap(a->a,a->Boolean.FALSE));
        noAlcanzable.remove(varInicial);
        
        boolean esta=false;
        noAlcanzable.entrySet().stream().forEach(s->System.out.println("Lo que hay en el map de validacion Key: "+s.getKey() + " Value: "+s.getValue()));
        for(String keyTran: sigma){
            if(!keyTran.equals(varInicial)){
                tranB=transiciones.get(varInicial);
                for(String valueTran: tranB){
                    System.out.println("key Prueba1: "+keyTran +" No alcanzable produccion: "+valueTran);
                    String[] transiccionSeparas = valueTran.split("");
                    Arrays.stream(transiccionSeparas).forEach(b->System.out.println("Key: "+ keyTran + " Value: " +b));
                    esta= Arrays.stream(transiccionSeparas).anyMatch(i->i.equals(keyTran));
                    if(esta==true){
                        noAlcanzable.put(keyTran, Boolean.TRUE);
                    }
                    System.out.println("key Prueba2: " + keyTran + " Value: "+esta);
                }   
            }   
        }
        List<String> sonAlcanzables= new ArrayList<>();
        List<String> noSonAlcanzables= new ArrayList<>();

        noAlcanzable.entrySet()
                .stream()
                .forEach(f->{
                    if(f.getValue()==true){
                    sonAlcanzables.add(f.getKey());
                    }else{
                    noSonAlcanzables.add(f.getKey());
                    }
        });
        
        sonAlcanzables.stream().forEach(n->System.out.println("Es alcanzable Key: " + n));
        noSonAlcanzables.stream().forEach(j->System.out.println("No son alcanzables Key: " + j));
        
        noAlcanzable.entrySet().stream().forEach(s->System.out.println("Lo que hay en el map de validacion despues Key: "+s.getKey() + " Value: "+s.getValue()));
        
        List<String> noSonAlcanzablesValidado= esAlcanzable(sonAlcanzables, noSonAlcanzables);
        //System.out.println("Transacciones en no alcanzable \n" +transiciones);
        if(!noSonAlcanzablesValidado.isEmpty()){
        chomsky.TextArea.setText(chomsky.TextArea.getText() + "\n \n" + " Eliminando transiciones no alcanzables... \n");
        }
        for(String son: noSonAlcanzablesValidado){
            System.out.println("Se elimino transicion no alcanzable: "+ son);
            chomsky.TextArea.setText(chomsky.TextArea.getText() + "\n"  + " Se elimino la transicion " +son + " no es alcanzable" );
            transiciones.remove(son);
        }
        List<String> TransicionesGeneranSigmae=obtenerKeyMap(transiciones);
        List<String> imprimirOrdenSigmae=ImprimirEnOrden(TransicionesGeneranSigmae);
        imprimirMap(imprimirOrdenSigmae);
        
        System.out.println("Map: \n"+transiciones);
    }
    
    //Recoro las otras transicionas para validar si se encuentra en las derivadas
    public List<String> esAlcanzable(List<String> sonAlcanzables, List<String> noSonAlcanzables){
    List<Boolean> esAlcanzableX2 = new ArrayList<>();
    List<String> transicion,guardar= new ArrayList<>();
    if(!esAlcanzableX2.isEmpty()){
        esAlcanzableX2.removeAll(esAlcanzableX2);
    }
    boolean ar=false;
    for(String noAlcanzable: noSonAlcanzables){
        String key= noAlcanzable;
        //System.out.println("Key no alcanzable en el metodo: " +key);
        if(ar==false){
        for(String alcanzable: sonAlcanzables){
            
            transicion=transiciones.get(alcanzable);
            //System.out.println("Key no alcanzable en el metodo primer for: " +key + " alcanzable Key: " + alcanzable);
            for(String value: transicion){
                System.out.println("Key no alcanzable en el metodo primer for: " +key + " alcanzable Key: " + alcanzable + " value: " + value);
                String[] transiccionSeparas = value.split("");
                esAlcanzableX2.add(Arrays.stream(transiccionSeparas).anyMatch(i->i.equals(key)));
            }
        }
        //Si encuentra algun verdadero 
        esAlcanzableX2.stream().forEach(g->System.out.println("Valores para validar No alcanzable Key: " + key + " valor: " +g));
        boolean otraVez = esAlcanzableX2.stream().anyMatch(n->n==true);
        System.out.println("Si es alcanzable o no key: " + key + " value:" + otraVez );
        if(otraVez==true){
            guardar.add(key);
            ar=true;
            System.out.println("Entro y se salio");
        }
        }
    }
    
    for(String h: guardar){
        noSonAlcanzables.remove(h);
        sonAlcanzables.add(h);
        System.out.println("Entro y si es alcanzable: " +h);
        if(noSonAlcanzables.size()>=1){
            System.out.println("Entro a la recursivida");
            noSonAlcanzables.stream().forEach(k->System.out.println("Recursividad no alcanzable key:" + h));
             esAlcanzable(sonAlcanzables, noSonAlcanzables);
         }
    }

    return noSonAlcanzables;
    }
    

    
    //Producciones Nulas
    public void detectarNulas(){
        List<String> transicion,keys= new ArrayList<>();
        List<String> sonNulas2= new ArrayList<>();
        List<String> nulasObtenidas= new ArrayList<>();


        keys= obtenerKeyMap(transiciones);
        boolean verdad,verdad2= false;
        for (String k: keys){
            transicion= transiciones.get(k);
            verdad= transicion.stream().anyMatch(h->h.equals("ε"));
            verdad2= transicion.stream().anyMatch(hr->hr.equals("λ"));
            if(verdad==true || verdad2==true){
                if(verdad==true){
                chomsky.TextArea.setText(chomsky.TextArea.getText() + "\n" +" La transicion "+ k + " es nula por tener la produccion  'ε'");
                }
                if(verdad2==true){
                chomsky.TextArea.setText(chomsky.TextArea.getText() + "\n" +" La transicion "+ k + " es nula por tener la produccion  'λ'");
                }
            sonNulas2.add(k);
            }
        }
        sonNulas2.stream().forEach(j->System.out.println("Son nulas Key:" + j));
        if(!sonNulas2.isEmpty()){
            nulasObtenidas=detectarNulasCombinadas(keys,sonNulas2);
        }
        
        
        nulasObtenidas.stream().forEach(m->System.out.println("Nulas obtenidas Key: " +m));
        /*nulasObtenidas.stream()
                .forEach(m-> chomsky.TextArea.setText(chomsky.TextArea.getText() + "\n" +" La Produccion "+ m + " Es nula"));*/

        eliminarNulas(nulasObtenidas);
    }
    
    public List<String> detectarNulasCombinadas(List<String> keys, List<String> nulas){
        List<String> transi= new ArrayList<>();
        boolean verdad,recur=false;
        int a = nulas.size();
        //System.out.println("Tamaño de list nulas" + a);
        for(String key: keys){
            if(recur==false){
                transi=transiciones.get(key);
                verdad=false;
                for(String tra: transi){
                    if(verdad==false){

                        verdad=estaEnLaTransicionNula(tra,nulas);
                        //System.out.println("La transcion Prueba1 "+key+" Es: " + verdad);
                        if(verdad==true && !key.equals(varInicial)){
                            //System.out.println("Añado al key: " + key);
                        chomsky.TextArea.setText(chomsky.TextArea.getText() + "\n" +" La transicion "+ key + " es nula por tener la produccion " + tra);
                        nulas.add(key);
                        //nulas.stream().forEach(o->System.out.println("Se prueba que es nula: " +o));
                        recur=true;
                        //detectarNulasCombinadas(keys, nulas);
                        }
                    }
                }
            }
        }
        for(String k: nulas){
            keys.remove(k);
        }
        
        //System.out.println("Tamaño de list nulas " + nulas.size());

        nulas.stream().forEach(j->System.out.println("La transicion: " +j+ " es Nula despues de detectar: "  ));
        keys.stream().forEach(i->System.out.println("Despues de remover key:" + i));
        if(nulas.size()>a){
            detectarNulasCombinadas(keys, nulas);
        }
        
        return nulas;
    }
        
    public boolean estaEnLaTransicionNula(String a,List<String> nulas){
        //Separo la produccion
        String[] simbolos= a.split("");
        boolean b=Arrays.stream(simbolos)
                .allMatch(g->estaEnElSimboloNulo(g, nulas));
        System.out.println("La produccion : "+ a + " Es:" +b);
    return b;
    }
    
    public boolean estaEnElSimboloNulo(String simbolo,List<String> nulas){
        boolean a= nulas.stream().anyMatch(b->b.equals(simbolo));
        System.out.println("La letra "+simbolo + " es:" +a);
    return a;
    }
    
    
     //Despues de detectar las nulas empezar a eliminar   
    public void eliminarNulas(List<String> nulasObtenidas){
      
        List<String> tra= obtenerKeyMap(transiciones);
        List<String> produccionesRecorrer=new ArrayList<>();
        
        for(String t: tra){
        mapNuevosSimbolos.put(t, produccionesRecorrer);
        }
        
        chomsky.TextArea.setText(chomsky.TextArea.getText() + "\n" );
        
        boolean esta= false;
        for(String nulaKey: nulasObtenidas){
            System.out.println("Nula obtenida Key: " +nulaKey);
            for(String key: tra){
             produccionesRecorrer=transiciones.get(key);
             //produccionesNuevas.removeAll(produccionesNuevas);
                for(String produccion: produccionesRecorrer){
                    String[] produccionesSeparadas = produccion.split("");
                    esta = Arrays.stream(produccionesSeparadas).anyMatch(p->p.equals(nulaKey));
                    if(esta==true){
                        System.out.println("Si encuentra: " + nulaKey + " en produccion: " + produccion + " de la transcion: "+key);
                    }
                    if(esta==true){
                        String produccionNueva="";
                        for(String separadoValue: produccionesSeparadas){
                            if(!separadoValue.equals(nulaKey)){
                                produccionNueva=produccionNueva+separadoValue;
                            }
                        }
                        System.out.println("Produccion nueva: " + produccionNueva);
                        produccionesNuevas.add(produccionNueva);
                        /*produccionesNuevas.stream().forEach(j->System.out.println("Despues de guardar: " +key + " value: "+j));
                        List<String> jj= Arrays.asList("Gregorio","Perez");
                       /* if(!produccionesNuevas.isEmpty()){
                            //System.out.println("Entro si no esta vacio :" +key);
                            /mapNuevosSimbolos.put(key, produccionesNuevas);
                            //System.out.println("Map: \n"+mapNuevosSimbolos);
                           
                    }*/
                        //producciones.add(produccionNueva);
                    }
                    
                }
                for(String p: produccionesNuevas){
                produccionesRecorrer.add(p);
                }
                produccionesRecorrer.remove(" ");
                produccionesRecorrer.remove("");
                produccionesRecorrer.remove("ε");
                produccionesRecorrer.remove("λ");

                transiciones.put(key, produccionesRecorrer);
                System.out.println("Map prueba: \n" +transiciones);
                 produccionesNuevas.clear();
            }
            
            chomsky.TextArea.setText(chomsky.TextArea.getText() + "\n" +" Se elimina "+ nulaKey+ " por nula ");
            
             List<String> TransicionesGeneranSigma=obtenerKeyMap(transiciones);
             List<String> imprimirOrdenSigma=ImprimirEnOrden(TransicionesGeneranSigma);
             imprimirMap(imprimirOrdenSigma);
        }
       produccionesNuevas.stream().forEach(l->System.out.println("Producciones nuevas Key: " + l));

        System.out.println("Map Nuevos Simbolos \n"+mapNuevosSimbolos );
        System.out.println("Map: \n"+transiciones );
  
        
    }
    
    
    
    public boolean esRecursiva(String key){
        List<String> tra= new ArrayList<>();
        List<Boolean> verda= new ArrayList<>();
        verda.removeAll(verda);
        tra=transiciones.get(key);
        
        for(String b: tra){
               //System.out.println("Key map: " +key+ " transicion: " + b);
               String[] transiccionSeparas = b.split("");
               //Arrays.stream(transiccionSeparas).forEach(f-> System.out.println("Split al string " +f));
                verda.add( Arrays.stream(transiccionSeparas)
                        .anyMatch(s->s.equals(key)));
                        //.allMatch(t-> recorrerTransicion(tra, t));
                //verda.stream().forEach(sx->System.out.println("Validando el boolean en Recursiva: " +sx));
        }
        
        boolean b = verda.stream().allMatch(val->val==true);
        
        return b;
    }
    

    
    
    public List<String> convertirSigma(String a){
        String[] c=a.split("/");
        List<String> g= Arrays.stream(c)
                .map(i-> i)
                .collect(Collectors.toList());
    return g;
    }
    
    public List<String> obtenerTransicionesSigma(Map<String,List<String>> transicion){
        List<String> traSigma = new ArrayList<>();
        transicion.entrySet()
                .stream()
                .forEach(t-> traSigma.add(t.getKey()));
        return traSigma;
    }
    
    public void generadores(String key,List<String> sigma){
        List<Boolean> seEncuentra=new ArrayList<Boolean>();
        seEncuentra.removeAll(seEncuentra);
        for(String transiccion: variablesTerminales){
            //System.out.println("Metodo generadores Transiciones: " +transiccion);
        boolean v=sigma.stream()
                .anyMatch(t->t.equals(transiccion));
        seEncuentra.add(v);
        }
        System.out.println("Metodo generadores Key: " +key);
        boolean c= seEncuentra.stream().anyMatch(t->t==true);
        if(c==false){
                    System.out.println("Metodo generadores si toca borrar Key: " +key);

        borrarNoGeneradoras.add(key);
        }
        
    }
    
    public boolean esGenerador(String transicion){
      boolean v=  variablesTerminales.stream()
                .anyMatch(t->t.equals(transicion) );
      return v;
    }
    
    public List<String> obtenerKeyMap(Map<String, List<String>> sigma){
    List<String> prueba= sigma.entrySet().stream().map(e->e.getKey()).collect(Collectors.toList());
    //prueba.stream().forEach(s->System.out.println("Dentro de prueba " + s ));
    return prueba;
    }
    
    public List<String> ImprimirEnOrden(List<String> sigma){
        List<String> eliminar = new ArrayList<>();
        List<String> mostrar = new ArrayList<>();

        for(String a: transcionesSigma){
            boolean val= sigma.stream().anyMatch(t->t.equals(a));
            if(!val){
            eliminar.add(a);
            }else{
                mostrar.add(a);
            }
        }
        mostrar.stream().forEach(s->System.out.println("Imprimir VariablesNoTerminales: " +s ));
    return mostrar;
    }
    
    public void imprimirMap(List<String> sigma){
        List<String> prueba=transiciones.get("S");
        //sigma.stream().forEach(s->System.out.println("Probando transiciones : "+s));
        
        List<String> transi= new ArrayList<>();
        List<String> transiInicial= new ArrayList<>();
        transiInicial= transiciones.get(varInicial);

        int con=0;
        int conInicial=0;
        //System.out.println("Tamañno sigma " + sigma.size() );
        contenidoLista="";
        contenidoListaInicial="";
        contenidoListaInicial=contenidoListaInicial + " " + varInicial + "→";
        for (String inicial: transiInicial){
        conInicial++;
        //contenidoListaInicial=contenidoListaInicial + inicial +"/";  
            if(conInicial==transiInicial.size()){
                contenidoLista= contenidoLista + inicial+"\n";
            }else{
                contenidoLista= contenidoLista + inicial + "/" ;
            }
            
        }
        chomsky.TextArea.setText(chomsky.TextArea.getText() + "\n"+ "\n" + contenidoListaInicial);
        
        for(String s: sigma ){
            
            if(!s.equals(varInicial)){
            contenidoLista=contenidoLista+ " " +s + "→";
            transi = transiciones.get(s);
            for(String b: transi){
            con++;
            if(con==transi.size()){
                contenidoLista= contenidoLista + b+"\n";
            }else{
                contenidoLista= contenidoLista + b + "/" ;
            }
            }
            con=0;
            contenidoLista= contenidoLista;
        }
        //System.out.println("Contador " + con);
                //System.out.println("Lo que hay en contenido Lista: "+contenidoLista);
        
        }
        chomsky.TextArea.setText(chomsky.TextArea.getText()  + contenidoLista);
    }
    
    
    public void esVariableInutil(List<String> vnt){
        List<String> variablesNtYT= Stream
                .concat(vnt.stream(), variablesTerminales.stream())
                .collect(Collectors.toList());
        List<String> transccionesEliminar=new ArrayList<>();
        List<String> transicionesValues=new ArrayList<>();  
         for(String tran: vnt){
                    System.out.println("Imprimir bien:"+tran.equals("B"));
                }
        variablesNtYT.forEach(g->System.out.println("Variables: "+g));
        vnt.stream().forEach(ss->System.out.println("Key Prueba3:"+ss));
        //Recorer el map para validar variables inutiles
        for(String key: vnt){
            transicionesValues=transiciones.get(key);
            transicionesValues.stream().forEach(ss->System.out.println("Key Prueba4: "+key.trim() + " Value: "+ss));
            //Recoro la lista con las transicciones de cada key
            for(String b: transicionesValues){
               System.out.println("Key map: " +key+ " transicion: " + b);
               String[] transiccionSepara = b.split("");
               //Arrays.stream(transiccionSepara).forEach(f-> System.out.println("Split al string " +f));
                boolean encontro = Arrays.stream(transiccionSepara)
                        .allMatch(t-> EstaEnVtVnt(variablesNtYT, t));
                System.out.println("Encontro Key:"+key+ " -Value: "+b+" " +encontro); 
                if(!encontro){
                transccionesEliminar.add(b);
                chomsky.TextArea.setText(chomsky.TextArea.getText() + "\n" +" " +"Se elimina de la transicion " + key + " la variable inutil: "+b );

                }
            }
            if(!transccionesEliminar.isEmpty()){
             for(String borrar: transccionesEliminar){
                transicionesValues.remove(borrar);

             }
             transiciones.put(key, transicionesValues);
            }
        }
        //Key del map para comparar con el original
        //List<String> imprimirOrden=ImprimirEnOrden(vnt);
        
        //imprimirOrden.stream().forEach(m->System.out.println("Orden de generadoras: " +m));
        imprimirMap(vnt);
        transccionesEliminar.stream().forEach(t->System.out.println("Transicion a eliminar:" +t));

    }
    
    public boolean EstaEnVtVnt(List<String> variables, String dato){
        boolean a=variables.stream().anyMatch(t-> dato.equals(t));
        System.out.println("Dato:" +dato+ " Resultado: " + a);
        return a;
    }
    

    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Vista.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Vista.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Vista.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Vista.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Vista().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextField InputVariablesTerminales;
    private javax.swing.JTextArea TextSigma;
    private javax.swing.JTextField TextVariableInicial;
    private javax.swing.JTextField TextVariablesTerminales;
    private javax.swing.JButton jButton1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JScrollPane jScrollPane1;
    // End of variables declaration//GEN-END:variables
}
